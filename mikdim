#!/usr/bin/python3

import sys, getopt, os, subprocess, re, yaml, schema, tempfile, shutil, shlex, glob, stat
from pprint import pprint

def getenv(key, default=None):
    return os.environ[key] if key in os.environ else default

def detectArgv0():
    argv0 = sys.argv[0]
    commandDir = os.path.dirname(argv0)
    commandName = os.path.basename(argv0)
    if commandDir[0:1] == '/':
        for path in getenv("PATH", "").split(":"):
            if path == '':
                continue
            if commandDir == path:
                return commandName
            testCommand = path + "/" + commandName
            if os.path.isfile(testCommand) and os.access(testCommand, os.X_OK) and not os.path.samefile(argv0, testCommand):
                return argv0
    return argv0
def detectCommandName(argv0):
    argv0 = os.path.basename(argv0)
    return re.sub(r'\.[^\.]+$', '', argv0)

ARGV0 = detectArgv0()

if detectCommandName(ARGV0) == 'mikdeb':
    CMD = 'mikdeb'
else:
    CMD = 'mikdim'

SEMI_TAG = "semi-tmp"
DEV_TAG = "dev"
DEBIAN_PACKAGE_SCRIPTS = ["preinst", "postinst", "prerm", "postrm"]
DEBIAN_ARCHITECTURES = ["all", "arm64", "amd64", "armel", "armhf", "i386", "mips64el", "ppc64el", "riscv64", "s390x"]
ALLOWED_BRANCHES = ["production", "staging", "master", "main"]
SEMVER_REGEXP = '^([0-9]+)\.([0-9]+)\.([0-9]+)(?:-([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?(?:\+[0-9A-Za-z-]+)?$'
DEBIAN_BUILD_DOCKER_IMAGE = "debian:latest"
DEBIAN_BUILD_DOCKER_IMAGE_MOUNT = "/tmp"

PRESERVED_ENV_VARS = ["HOME", "PATH"]

DOCKERFILE_CONTENT = """# Dockerfile for building {finalImage} from {image} 
FROM {image}
{preuser}
COPY archive.tar.gz /tmp/archive.tar.gz
COPY postprocess.sh /tmp/postprocess.sh
RUN bash /tmp/postprocess.sh
{postuser}
"""

POSTPROCESS_CONTENT = """#!/bin/bash
set -e
final_dir={finalDir}
postprocess_script={postprocessScript}
if [ -n "$final_dir" ]; then
    mkdir -p "$final_dir"
    cd "$final_dir"
    tar xzf "/tmp/archive.tar.gz"
fi
rm -f "/tmp/archive.tar.gz"
if [ -n "$postprocess_script" ]; then
    export ROOT_DIR="/"
    export PACKAGE_DIR="`pwd`"
    eval "$postprocess_script"
fi
rm -f "/tmp/postprocess.sh"
"""

DPKG_DEB_CONTENT = """#!/bin/bash
set -e
export PROJECT_VERSION={projectVersion}
base_dir={baseDir}
package_subdir={packageSubdir}
archive_file={archiveFile}
postprocess_script={postprocessScript}
final_dir={finalDir}
package_name={packageName}
conffiles_regexp={conffilesRegexp}
rm -rf "$base_dir/*.deb"
mkdir -p "$base_dir/$package_subdir/$final_dir"
cd "$base_dir/$package_subdir/$final_dir"
tar xzf "$base_dir/$archive_file"
rm "$base_dir/$archive_file"
chown -R root:root "$base_dir/$package_subdir"
if [ -n "$postprocess_script" ]; then
    export ROOT_DIR="$base_dir/$package_subdir"
    export PACKAGE_DIR="`pwd`"
    eval "$postprocess_script"
fi
cd "$base_dir/$package_subdir"
if [ -n "$conffiles_regexp" ]; then
    find . -type f | sed 's|^./|/|;/^\/DEBIAN\(\/\|$\)/d' | grep -E "$conffiles_regexp" > DEBIAN/conffiles || rm DEBIAN/conffiles
fi
cd "$base_dir"
dpkg-deb -b "$package_subdir" .
rm -rf "$package_subdir"
mkdir "$package_subdir"
mv *.deb "$package_subdir/"
chown --reference="$0" -R "$package_subdir"
rm "$0"
"""

DEBIAN_CONTROL_FILE_KEYS = [
        "Package", "Version", "Maintainer", "Architecture", "Description"
]

DEBIAN_DEP_FIELDS = {
        "depends": "Depends",
        "recommends": "Recommends",
        "suggests": "Suggests",
        "pre-depends": "Pre-Depends",
        "conflicts": "Conflicts",
        "enhaces": "Enhaces"
}

DEP_FIELDS_SCHEMA = {}

for key, value in DEBIAN_DEP_FIELDS.items():
    DEBIAN_CONTROL_FILE_KEYS.append(value)
    DEP_FIELDS_SCHEMA[schema.Optional(key)] = schema.Or([str], str, None)


SCHEMA = {
    "mikdim": {
        "images": [
            {
                "name": str,
                "build": str,
                schema.Optional("prepare-command"): schema.Or(str, [str]),
                schema.Optional("prepare-command-dev"): schema.Or(str, [str]),
                schema.Optional("project-dir"): schema.Or(str, None),
                schema.Optional("postprocess"): schema.Or(str, [str]),
                schema.Optional("environment"): {
                    schema.Optional(str): schema.Or(str, None)
                },
                schema.Optional("environment-dev"): {
                    schema.Optional(str): schema.Or(str, None)
                },
                schema.Optional("subdir"): str,
                schema.Optional("exclude"): [str],
                schema.Optional(str): object
            }
        ]
    },
    "mikdeb": {
        schema.Optional("output-dir"): schema.Or(str, None),
        "debian-packages": [
            {
                "name": str,
                schema.Optional("prepare-command"): schema.Or(str, [str]),
                schema.Optional("project-dir"): str,
                schema.Optional("postprocess"): schema.Or(str, [str]),
                schema.Optional("environment"): {
                    schema.Optional(str): schema.Or(str, None)
                },
                schema.Optional("subdir"): str,
                schema.Optional("exclude"): [str],
                schema.Optional("architecture"): schema.Or(*DEBIAN_ARCHITECTURES),
                schema.Optional("description"): str,
                schema.Optional("long-description"): str,
                schema.Optional("maintainer"): str,
                schema.Optional("config-files"): schema.Or(str, [str], None),
                schema.Optional("etc-config-files"): bool,
                schema.Optional("scripts"): schema.Or(str, {schema.Optional(str): str}),
                schema.Optional(str): object,
                **DEP_FIELDS_SCHEMA
            }
        ]
    }
}

def integrationPluginGit(options, detect):
    data = {}
    if detect["version"]:
        try:
            projectVersion = subprocess.check_output(["git", "describe"])
            projectVersion = projectVersion.decode("utf-8")
            projectVersion = projectVersion.strip()
        except:
            projectVersion = None
        if projectVersion != None:
            data["version"] = projectVersion

    if detect["branch"]:
        try:
            projectBranch = subprocess.check_output(["git", "rev-parse", "--abbrev-ref", "HEAD"])
            projectBranch = projectBranch.decode("utf-8")
            projectBranch = projectBranch.strip()
            if projectBranch == 'HEAD' or projectBranch == '':
                projectBranch = None
        except:
            projectBranch = None
        if projectBranch != None:
            data["branch"] = projectBranch
    return data

def integrationPluginGitlab(options, detect):
    data = {}
    if detect["imagePrefix"]:
        imagePrefix = getenv("CI_REGISTRY_IMAGE")
        if imagePrefix != None and imagePrefix != '':
            data["imagePrefix"] = imagePrefix
    if detect["version"]:
        version = getenv("CI_COMMIT_TAG")
        if version != None and version != '':
            data["version"] = version
    if detect["branch"]:
        branch = getenv("CI_COMMIT_BRANCH")
        if branch != None and branch != '':
            data["branch"] = branch
    return data

INTEGRATION_PLUGINS = {
        "git": integrationPluginGit,
        "gitlab": integrationPluginGitlab
}

def optPush(command, args, params):
    if command == "create":
        return args["default"] if "default" in args else []
    elif command == "opt":
        return [":", "="]
    elif command == "val":
        unique = args["unique"] if "unique" in args else True
        if not unique or not params["val"] in params["oldVal"]:
            params["oldVal"].append(params["val"])
        return params["oldVal"]

def optPushNullable(command, args, params):
    if command == "create":
        return args["default"] if "default" in args else []
    elif command == "opt":
        return [":", "="]
    elif command == "val":
        opt = args["opt"].lstrip("-")
        if "nullableOpts" in args and opt in args["nullableOpts"]:
            return None
        if params["oldVal"] == None:
            return None
        return optPush(command, args, params)

def optPushOpt(command, args, params):
    if command == "create":
        return optPush(command, args, params)
    elif command == "opt":
        return ["", ""]
    elif command == "val":
        opt = params["opt"].lstrip("-")
        if "transform" in args and opt in args["transform"]:
            opt = args["transform"][opt]
        return optPush(command, args, {"val": opt, "opt": params["opt"], "oldVal": params["oldVal"]})

def optSetValue(command, args, params):
    if command == "create":
        return args["default"] if "default" in args else None
    elif command == "opt":
        return [":", "="]
    elif command == "val":
        return params["val"]

def optSet(command, args, params):
    default = True if (args["default"] if "default" in args else False) else False
    if command == "create":
        return default
    elif command == "opt":
        return ["", ""]
    elif command == "val":
        return not default

OPTIONS_ALL = {
    "integrationPlugins": {"fn": optPushOpt, "opts": ["G", "git", "L", "gitlab"], "transform": {"G": "git", "L": "gitlab"}},
    "project": {"fn": optSetValue, "opts": ["p", "project"]},
    "preserveEnvironment": {"fn": optSet, "opts": ["e", "preserve-environment"]},
    "dryRun": {"fn": optSet, "opts": ["D", "dry-run"]},
    "list": {"fn": optSet, "opts": ["l", "list"]},
    "help": {"fn": optSet, "opts": ["h", "help"]}
}

OPTIONS_SPECIFIC = {
    "mikdim": {
        "devBuild": {"fn": optSet, "opts": ["d", "dev"], "setIfEmpty": ["prodBuild", True]},
        "prodBuild": {"fn": optSet, "opts": ["prod"]},
        "imagePrefix": {"fn": optSetValue, "opts": ["P", "prefix"]},
        "allowedBranches": {"fn": optPushNullable, "opts": ["a", "allow-branch", "A", "allow-all-branches"], "nullableOpts": ["A", "allow-all-branches"], "setIfEmpty": ["_self", ALLOWED_BRANCHES]},
        "tags": {"fn": optPush, "opts": ["t", "tag"]},
        "semiTag": {"fn": optSetValue, "opts": ["s", "semi-tag"], "default": SEMI_TAG},
        "projectVersioning": {"fn": optSet, "opts": ["n", "no-project-version"], "default": True},
        "projectBranchVersioning": {"fn": optSet, "opts": ["b", "no-project-branch"], "default": True},
        "wantedObjects": {"fn": optPush, "opts": ["i", "image"], "setIfEmpty": ["_self", None]},
        "push": {"fn": optSet, "opts": ["push"]},
        "pushOnly": {"fn": optSet, "opts": ["pushOnly"]},
        "untag": {"fn": optSet, "opts": ["u", "untag"]},
        "prune": {"fn": optSet, "opts": ["prune"]}
    },
    "mikdeb": {
        "wantedObjects": {"fn": optPush, "opts": ["P", "package"], "setIfEmpty": ["_self", None]},
        "projectVersion": {"fn": optSetValue, "opts": ["V", "project-version"]},
        "buildImage": {"fn": optSetValue, "opts": ["i", "image"], "default": DEBIAN_BUILD_DOCKER_IMAGE},
        "buildImageMount": {"fn": optSetValue, "opts": ["i", "image"], "default": DEBIAN_BUILD_DOCKER_IMAGE_MOUNT},
        "maintainer": {"fn": optSetValue, "opts": ["m", "maintainer"]},
        "outputDir": {"fn": optSetValue, "opts": ["o", "output-dir"], "relativePath": True},
    }
}

def helpPrint(options):
    finalOpts = []
    shortOptsLen = 0
    longOptsLen = 0
    for optionDef in options:
        [short, long, description, command, *x] = optionDef + [None]
        if command != None and CMD != command:
            continue
        shortOptsLen = max(shortOptsLen, len(short))
        longOptsLen = max(longOptsLen, len(long))
        finalOpts.append(optionDef)
    for optionDef in finalOpts:
        [short, long, description, *x] = optionDef
        shortLen = shortOptsLen - len(short)
        longLen = longOptsLen - len(long)
        print("  {}{} {}{}  - {}".format(short, " " * shortLen, long, " " * longLen, description), file=sys.stderr)

def printHelp():
    print("usage: {} [options]".format(ARGV0), file=sys.stderr)
    print("options:", file=sys.stderr)
    helpPrint([
        ["-d", "--dev",                     "invoke dev build of the images", "mikdim"],
        ["",   "--prod",                    "invoke prod build of the images", "mikdim"],
        ["-t", "--tag <tag>",               "specify some another special tag", "mikdim"],
        ["-p", "--project <project>",       "specify directory or config file of the project where images should be built"],
        ["-P", "--prefix <image-prefix>",   "specify image prefix", "mikdim"],
        ["-G", "--git",                     "Use branch/version from git", "mikdim"],
        ["-G", "--git",                     "Use version from git", "mikdeb"],
        ["-L", "--gitlab",                  "Use branch/version from gitlab CI variables", "mikdim"],
        ["-L", "--gitlab",                  "Use version from gitlab CI variables", "mikdeb"],
        ["-V", "--project-version",         "Specify project version", "mikdeb"],
        ["-n", "--no-project-version",      "disable project version tagging (use with --git or --gitlab)", "mikdim"],
        ["-b", "--no-project-branch",       "disable project branch tagging (use with --git or --gitlab)", "mikdim"],
        ["-e", "--preserve-environment",    "preserve environment variables"],
        ["-a", "--allow-branch <branch>",   "allow branch name (default branch names if none given are {})".format(", ".join(ALLOWED_BRANCHES)), "mikdim"],
        ["-A", "--allow-all-branches",      "allow all branch names", "mikdim"],
        ["-i", "--image <image-name>",      "build only this image (multiple images may be specified)", "mikdim"],
        ["-i", "--image <image-name>",      "build debian package using this docker image (default '{}')".format(DEBIAN_BUILD_DOCKER_IMAGE), "mikdeb"],
        ["-w", "--image-working-dir <dir>", "empty directory inside of the building image (default '{}')".format(DEBIAN_BUILD_DOCKER_IMAGE_MOUNT), "mikdeb"],
        ["-m", "--maintainer <maintainer>", "set the default maintainer (will be used if package has no maintainer specified)", "mikdeb"],
        ["-P", "--package <package-name>",  "build only this package (multiple packages may be specified)", "mikdeb"],
        ["-s", "--semi-tag <tag>",          "specify the tag of the semiproduct (default '{}')".format(SEMI_TAG), "mikdim"],
        ["-o", "--output-dir <dir>",        "set the output directory where built packages should be stored", "mikdeb"],
        ["-D", "--dry-run",                 "just print building info and exit"],
        ["-l", "--list",                    "just list all images and exit", "mikdim"],
        ["-l", "--list",                    "just list all debian packages and exit", "mikdeb"],
        ["",   "--push",                    "push the images to the registry (registry login is not part of this command)", "mikdim"],
        ["",   "--push-only",               "only push the images, don't build", "mikdim"],
        ["-u", "--untag",                   "untag images after build (and push) is finished", "mikdim"],
        ["",   "--prune",                   "prune the image and builder cache", "mikdim"],
        ["-h", "--help",                    "show this help"]
    ])

def pathToAbsolute(path):
    if path == '' or path[0:1] == '/':
        return path
    return os.getcwd() + "/" + path

def parseOptions():
    optionsDef = {}
    optionsDef.update(OPTIONS_ALL)
    optionsDef.update(OPTIONS_SPECIFIC[CMD])

    options = {}
    shortOpts = ""
    longOpts = []
    optMap = {}

    for (key, optDef) in optionsDef.items():
        fn = optDef["fn"]
        options[key] = fn("create", optDef, {})
        (shortSuffix, longSuffix) = fn("opt", optDef, {})
        for opt in optDef["opts"]:
            if len(opt) > 0:
                if len(opt) == 1:
                    optMap["-" + opt] = key
                    shortOpts += opt + shortSuffix
                else:
                    optMap["--" + opt] = key
                    longOpts += [opt + longSuffix]


    (opts, args) = getopt.getopt(sys.argv[1:], shortOpts, longOpts)
    for (opt, value) in opts:
        key = optMap[opt]
        optDef = optionsDef[key]
        fn = optDef["fn"]
        options[key] = fn("val", optDef, {"opt": opt, "val": value, "oldVal": options[key]})

    for (key, optDef) in optionsDef.items():
        if "setIfEmpty" in optDef and not options[key]:
            (myKey, myValue) = optDef["setIfEmpty"]
            if myKey == "_self" or myKey == None:
                myKey = key
            options[myKey] = myValue
        if "relativePath" in optDef and optDef["relativePath"]:
            if options[key] != None:
                options[key] = pathToAbsolute(options[key])
            

    return options 

def enterProject(project, defaultConfig):
    if project == None:
        project = "."
    if os.path.isdir(project):
        os.chdir(project)
        file = defaultConfig
    elif os.path.isfile(project):
        os.chdir(os.path.dirname(project))
        file = os.path.basename(project)
    if os.path.isfile(file):
        return file
    return None

def loadConfig(file):
    with open(file, "r") as stream:
        try:
            config = yaml.safe_load(stream)
        except:
            return None
    return config

def checkConfig(config):
    configSchema = schema.Schema(SCHEMA[CMD])
    try:
        return configSchema.validate(config)
    except:
        return None

def putFile(directory, file, template, *args, **kwargs):
    file = "{}/{}".format(directory, file)
    if args or kwargs:
        content = template.format(*args, **kwargs)
    else:
        content = template
    with open(file, 'w') as f:
        f.write(content)


def createProjectArchive(tempDir, objectConfig, additionalExclude = []):
    subdir = objectConfig['subdir'] if 'subdir' in objectConfig else '.'
    excludeDirs = objectConfig['exclude'] if 'exclude' in objectConfig else []

    archive = "{}/archive-{}.tar.gz".format(os.path.realpath(tempDir), createProjectArchive.archiveNumber)
    createProjectArchive.archiveNumber += 1
    excludeArgs = additionalExclude.copy()
    if not os.path.isdir(subdir):
        raise Exception("Image sbdir is not a directory")
    for excludeDir in excludeDirs:
        excludeArgs.append("--exclude")
        excludeArgs.append(re.sub(r'^/*', './', excludeDir))
    cwd = os.getcwd()
    os.chdir(subdir)
    if subprocess.run(["tar", "-czf", archive, "--exclude", "./.git"] + excludeArgs + ["."]).returncode != 0:
        raise Exception("Cannot create archive")
    os.chdir(cwd)
    return archive

createProjectArchive.archiveNumber = 1

def getDefaultPreservedEnvVars():
    env = {}
    for var in PRESERVED_ENV_VARS:
        if var in os.environ:
            env[var] = os.environ[var]
    return env

def getEnvVars(objectConfig, devBuild):
    envKey = 'environment-dev' if devBuild else 'environment'
    env = None
    if not objectConfig['preserveEnvironment']:
        env = getDefaultPreservedEnvVars()
    if not (envKey in objectConfig):
        return env
    if env == None:
        env = dict(os.environ)
    for var, val in objectConfig[envKey].items():
        if val != None:
            env[var] = val
        elif var in env:
            del env[var]
    return env

def buildSemiProduct(imageConfig, tempDir, envVars):
    if not os.path.isdir(imageConfig['build']):
        raise Exception("Build directory of image '{}' is not a directory".format(imageConfig['finalImage']))
    if not os.path.isfile("{}/Dockerfile".format(imageConfig['build'])):
        raise Exception("Build directory does not contain Dockerfile")
    imageArgs = []
    for img in imageConfig["semiImages"]:
        imageArgs.append("-t");
        imageArgs.append(img)
    if subprocess.run(["docker", "build", "--pull"] + imageArgs + [imageConfig['build']], env=envVars).returncode != 0:
        raise Exception("Cannot build semiproduct image")

def buildCommand(commandDefinition):
    if not isinstance(commandDefinition, str):
        commandDefinition = "\n".join(commandDefinition)
    return commandDefinition

def buildFinalProduct(imageConfig, tempDir, projectArchive):
    dockerDir = "{}/docker-{}".format(tempDir, imageConfig['name'])
    os.mkdir(dockerDir)
    finalDir = imageConfig["project-dir"] if "project-dir" in imageConfig else None
    if finalDir == None:
        finalDir = ""
    postprocessScript = buildCommand(imageConfig["postprocess"] if "postprocess" in imageConfig else "")
    user = subprocess.check_output(["docker", "image", "inspect", "--format", "{{ .Config.User }}", "--", imageConfig["semiImages"][0]]).decode("utf-8").strip()
    preuser=""
    postuser=""
    if user != 'root' and user != '':
        preuser="USER root"
        if not re.search(r'^[a-zA-Z_\-]+$', user):
            raise Exception("Invalid docker user set for image: '{}'".format(user))
        postuser="USER {}".format(user)
    putFile(dockerDir, "Dockerfile", DOCKERFILE_CONTENT, image=imageConfig["semiImages"][0], finalImage=imageConfig["finalImage"], preuser=preuser, postuser=postuser)
    putFile(dockerDir, "postprocess.sh", POSTPROCESS_CONTENT, finalDir=shlex.quote(finalDir), postprocessScript=shlex.quote(postprocessScript))
    shutil.copy(projectArchive, "{}/archive.tar.gz".format(dockerDir))
    imageArgs = []
    for img in imageConfig["finalImages"]:
        imageArgs.append("-t");
        imageArgs.append(img)
    if imageArgs:
        if subprocess.run(["docker", "build"] + imageArgs + [dockerDir]).returncode != 0:
            raise Exception("Cannot build final production image")
    else:
        raise Exception("No final tag specified")
    shutil.rmtree(dockerDir)

def pushTags(imageConfig):
    failed = False
    for image in imageConfig["finalImages"]:
        if subprocess.run(["docker", "push", "--", image]).returncode != 0:
            failed = True
    if failed:
        raise Exception("Cannot push tags")

def cleanupBuild(imageConfig, tempDir):
    for tag in imageConfig["cleanupImages"]:
        subprocess.run(["docker", "image", "rm", "-f", "--", tag])
    if imageConfig["prune"]:
        subprocess.run(["docker", "image", "prune", "-f"])
        subprocess.run(["docker", "builder", "prune", "-f"])

def createFinalImageName(name, options):
    imagePrefix = options["imagePrefix"]

    if imagePrefix == '':
        imagePrefix = None

    if imagePrefix == None:
        return name

    if name == 'main':
        return options["imagePrefix"]

    return options["imagePrefix"] + "/" + name

def unique(array):
    finalArray = []
    for item in array:
        if not item in finalArray:
            finalArray.append(item)
    return finalArray

def tagToImage(tag, image):
    return "{}:{}".format(image, tag)

def tagsToImages(tags, image):
    images = []
    for tag in unique(tags):
        images.append(tagToImage(tag, image))
    return images


def getIntegrationPlugin(name):
    if name in INTEGRATION_PLUGINS:
        return INTEGRATION_PLUGINS[name]
    return None

def detectVersion(projectVersion):
    projectVersion = projectVersion.strip()
    reMatch = re.search('^v?(.*)$', projectVersion)
    if reMatch:
        projectVersion = reMatch[1]

    if not re.search(SEMVER_REGEXP, projectVersion):
        return None
    return projectVersion

def runIntegrationPlugins(options, detectEnabled):
    data = {}
    detectAll = ["version", "branch", "imagePrefix"]
    detect = dict.fromkeys(detectAll, False)
    detect.update(dict.fromkeys(detectEnabled, True))
    detectAll = []
    for (d, en) in detect.items():
        if en:
            detectAll.append(d)
    for plugin in options["integrationPlugins"]:
        plugin = getIntegrationPlugin(plugin)
        if plugin != None:
            pluginData = {}
            pluginData.update(plugin(options, detect))
            for key in pluginData.keys():
                if pluginData[key] == None:
                    del pluginData[key]
            pluginData.update(data)
            data = pluginData
            
            detectAllNew = []
            for d in detectAll:
                if d in data and data[d] != None:
                    detect[d] = False
                else:
                    detectAllNew.append(d)
            detectAll = detectAllNew
        else:
            data = {}

    tags = []
    if "version" in data and data["version"] != None:
        version = detectVersion(data["version"])
        if version != None:
            if "projectVersioning" in options and options["projectVersioning"]:
                tags.append(version)
            if "projectVersion" in options and options["projectVersion"] == None:
                options["projectVersion"] = version
    if "branch" in data and data["branch"] != None and "projectBranchVersioning" in options and options["projectBranchVersioning"]:
        branch = data["branch"]
        if options['allowedBranches'] == None or branch in options['allowedBranches']:
            tags.append(branch)

    options["integrationTags"] = tags
    if (not "imagePrefix" in options or options["imagePrefix"] == None) and "imagePrefix" in data:
        options["imagePrefix"] = data["imagePrefix"]

def invokePrepareCommand(objectConfig, devBuild, envVars):
    if devBuild:
        prepareCommandKey = 'prepare-command-dev'
    else:
        prepareCommandKey = 'prepare-command'

    prepareCommand = objectConfig[prepareCommandKey] if prepareCommandKey in objectConfig else None
    
    if prepareCommand == None:
        return

    prepareCommand = buildCommand(prepareCommand)
    prepareCommand = ["bash", "-c", prepareCommand]

    if not prepareCommand:
        raise Exception("Cannot invoke empty prepare command")
    if subprocess.run(prepareCommand, env=envVars).returncode != 0:
        raise Exception("Prepare command failed")



def processSingleImage(imageConfig, options, tempDir, devBuild, tags):
    imageConfig = imageConfig.copy()
    imageConfig["preserveEnvironment"] = options["preserveEnvironment"]
    imageConfig["finalImage"] = createFinalImageName(imageConfig["name"], options)
    imageConfig["semiImages"] = []
    imageConfig["cleanupImages"] = []
    imageConfig["prune"] = options["prune"]

    imageConfig["finalTags"] = tags
    
    if devBuild:
        if not imageConfig["finalTags"]:
            imageConfig["finalTags"].append(DEV_TAG)
    else:
        semiImage = tagToImage(options["semiTag"], imageConfig["finalImage"])
        imageConfig["semiImages"].append(semiImage)
        imageConfig["cleanupImages"].append(semiImage)

    imageConfig["finalImages"] = tagsToImages(imageConfig["finalTags"], imageConfig["finalImage"])

    if options["untag"]:
        imageConfig["cleanupImages"] = imageConfig["cleanupImages"] + imageConfig["finalImages"]

    if devBuild:
        imageConfig['semiImages'] = imageConfig["finalImages"]

    if options['list']:
        print(imageConfig["finalImage"])
        return True
    
    print("Building image {} as {}".format(imageConfig["finalImage"], "dev" if devBuild else "prod"), file=sys.stderr)
    if not devBuild:
        print("Semiproduct image: {}".format(imageConfig["semiImages"][0]), file=sys.stderr)
    print("Tags: {}".format(", ".join(imageConfig["finalTags"])), file=sys.stderr)
    if options["push"]:
        print("Images will be pushed to the repository", file=sys.stderr)
    print("", file=sys.stderr)

    if options["dryRun"]:
        return True

    if not imageConfig["finalTags"]:
        print("Warning: no tags given for building this image, skipping", file=sys.stderr)
        return True

    ret = True
    try:
        envVars = getEnvVars(imageConfig, devBuild)
        if not options["pushOnly"]:
            invokePrepareCommand(imageConfig, devBuild, envVars)
            if not devBuild:
                archive = createProjectArchive(tempDir, imageConfig)
            buildSemiProduct(imageConfig, tempDir, envVars)
            if not devBuild:
                buildFinalProduct(imageConfig, tempDir, archive)
        if options["push"] or options["pushOnly"]:
            pushTags(imageConfig)
    except Exception as e:
        print("Error: building image {} failed: {}".format(imageConfig["finalImage"], e), file=sys.stderr)
        ret = False
    cleanupBuild(imageConfig, tempDir)
    return ret

def processImage(imageConfig, options, tempDir):
    ok = True
    tags = options["integrationTags"] + options["tags"]
    if options["prodBuild"]:
        if not processSingleImage(imageConfig, options, tempDir, False, tags):
            ok = False
    if options["devBuild"]:
        if options["prodBuild"]:
            tags = [DEV_TAG]
        if not processSingleImage(imageConfig, options, tempDir, True, tags):
            ok = False
    return ok

class Wildcards:
    def __init__(self, patterns):
        self.patterns = map(lambda x: Wildcard(x), patterns)
    def getEgrepRegexp(self, slashFix = True):
        slash = ''
        if slashFix:
            slash = '/?'
        return "^"+slash+"(" + "|".join(map(lambda x: x.getEgrepRegexp(), self.patterns)) + ")$"

class Wildcard:
    def __init__(self, pattern):
        self.parts = []
        for x in re.split(r'(\\.)', pattern):
            if x == '':
                continue
            if x[:1] == "\\":
                if len(x) < 2:
                    self.putConstant(x)
                elif len(x) > 2:
                    raise Exception("Bug")
                elif x[1:2] in ['*', '?', '\\']:
                    self.putConstant(x[1:2])
                else:
                    self.putConstant(x)
            else:
                self.processPart(x)

    def processPart(self, part):
        for x in re.split(r'(\?|\*\*?)', part):
            if x == '':
                continue
            if x in ['*', '**', '?']:
                self.putWildcard(x)
            else:
                self.putConstant(x)

    def putConstant(self, constant):
        last = self.parts[-1] if len(self.parts) > 0 else None
        if last != None and last[0] == 'const':
            last[1] += constant
        else:
            self.parts.append(["const", constant])

    def putWildcard(self, wildcard):
        last = self.parts[-1] if len(self.parts) > 0 else None
        if last != None and last[0] == 'wildcard' and wildcard in ['*', '**'] and last[1] in ['*', '**']:
            if wildcard == '**':
                last[1] = '**'
        else:
            self.parts.append(["wildcard", wildcard])

    def getEgrepRegexp(self):
        regexp = ''
        for x in self.parts:
            if x[0] == 'wildcard':
                if x[1] == '*':
                    regexp += '[^/]*'
                elif x[1] == '**':
                    regexp += '.*'
                elif x[1] == '?':
                    regexp += '[^/]'
                else:
                    raise Exception("Bug")
            elif x[0] == 'const':
                regexp += re.sub(r'([\(\)\*\+\.\?\[\]\\\$\^\{\|\}])', r'\\\1', x[1])
            else:
                raise Exception("Bug")
        return regexp

def getConfigFilesRegexp(packageConfig):
    conffilesWildcards = packageConfig['config-files'] if 'config-files' in packageConfig else None
    if conffilesWildcards == None:
        conffilesWildcards = []
    elif isinstance(conffilesWildcards, str):
        conffilesWildcards = [conffilesWildcards]
    else:
        conffilesWildcards = conffilesWildcards.copy()
    if not 'etc-config-files' in packageConfig or packageConfig['etc-config-files']:
        conffilesWildcards.append('/etc/**')
    if conffilesWildcards:
        conffilesRegexp = Wildcards(conffilesWildcards).getEgrepRegexp()
    else:
        conffilesRegexp = ''
    return conffilesRegexp


def createBuildScript(packageConfig, archiveFile, tempDir):
    buildScript = "build-" + str(packageConfig["buildId"]) + ".sh"
    postprocessScript = buildCommand(packageConfig["postprocess"] if "postprocess" in packageConfig else "")
    finalDir = packageConfig["project-dir"] if "project-dir" in packageConfig else "/"
    finalDir = finalDir.lstrip("/")
    conffilesRegexp = getConfigFilesRegexp(packageConfig)
    if finalDir == "":
        finalDir = "."
    putFile(
        tempDir,
        buildScript,
        DPKG_DEB_CONTENT,
        baseDir=shlex.quote(packageConfig["buildDir"]),
        packageSubdir=shlex.quote(packageConfig["packageSubdir"]),
        archiveFile=shlex.quote(archiveFile),
        postprocessScript=shlex.quote(postprocessScript),
        packageName=shlex.quote(packageConfig["name"]),
        conffilesRegexp=shlex.quote(conffilesRegexp),
        finalDir=shlex.quote(finalDir),
        projectVersion=shelx.quote(packageConfig["projectVersion"])
    )
    return buildScript

def normalizeDepField(value):
    if value == None:
        return None
    if isinstance(value, list):
        value = ",".join(value)

    value = value.replace('\n', ',')
    values = []
    for val in value.split(','):
        val = val.strip()
        if val != '':
            values.append(val)
    if not values:
        return None
    return ", ".join(values)

def createDebianControlFile(packageConfig, tempDir):
    debianDir = tempDir + "/" + packageConfig["debianDir"]
    description = packageConfig["description"] if "description" in packageConfig else packageConfig["name"]

    data = {
        "Package": packageConfig["name"],
        "Version": packageConfig["projectVersion"],
        "Maintainer": packageConfig["maintainer"],
        "Architecture": packageConfig["architecture"],
        "Description": description
    }

    for key, dataKey in DEBIAN_DEP_FIELDS.items():
        configVal = packageConfig[key] if key in packageConfig else None
        configVal = normalizeDepField(configVal)
        if configVal != None:
            data[dataKey] = configVal

    controlContent = ""
    for key in DEBIAN_CONTROL_FILE_KEYS:
        value = data[key] if key in data else None
        if value != None:
            value = re.sub(r'\n', '\n ', value.strip())
            controlContent+="{}: {}\n".format(key, value)
    putFile(debianDir, "control", controlContent)

def installMaintainerScripts(packageConfig, tempDir):
    scripts = packageConfig["scripts"] if "scripts" in packageConfig else None
    if scripts == None or scripts == '':
        return []
    scriptsDir = None
    if isinstance(scripts, str):
        if not os.path.isdir(scripts):
            return []
        scriptsDir = scripts
        scripts = {}
        for script in DEBIAN_PACKAGE_SCRIPTS:
            scriptPath = scriptsDir + "/" + script
            if os.path.isfile(scriptPath):
                scripts[script] = scriptPath
    else:
        for script in scripts.keys():
            if not script in DEBIAN_PACKAGE_SCRIPTS:
                raise Exception("Invalid script: {}".format(script))
            if not os.path.isfile(scripts[script]):
                raise Exception("{} script does not exist: {}".format(script, scripts[script]))
    if scriptsDir == '.':
        scriptsDir = None
    exclude = []
    if scriptsDir != None:
        exclude.append(scriptsDir)
    debianDir = tempDir + "/" + packageConfig["debianDir"]
    for script, scriptPath in scripts.items():
        if scriptsDir == None and scriptPath[0:1] != '/':
            exclude.append(scriptPath)
        dst = debianDir + "/" + script
        shutil.copy(scriptPath, dst)
        os.chmod(dst, stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR | stat.S_IRGRP | stat.S_IXGRP | stat.S_IROTH | stat.S_IXOTH)

    return exclude 

def buildDebianPackage(packageConfig, buildScript, tempDir):
    fullBuildScript = packageConfig["buildDir"] + "/" + buildScript
    volume = tempDir + ":" + packageConfig["buildDir"]
    if subprocess.run(["docker", "run", "-t", "-v", volume, "--user", "root", "--", packageConfig["buildImage"], "bash", fullBuildScript]).returncode != 0:
        raise Exception("Cannot build debian package")
    
    debFiles = glob.glob(tempDir + "/" + packageConfig["packageSubdir"] + "/*.deb")
    if len(debFiles) != 1:
        if len(debFiles) > 1:
            raise Exception("For some reason, multiple debian packages were created, giving up. (Maybe a bug?)")
        raise Exception("Debian package was not created")
    return debFiles[0]

def cleanupDebianBuild(packageConfig, tempDir, success):
    if not success:
        volume = tempDir + ":" + packageConfig["buildDir"]
        subprocess.run(["docker", "run", "-t", "-v", volume, "--user", "root", "--", packageConfig["buildImage"], "bash", "-c", "rm -rf /tmp/*"])

def createBasicPackageStruct(packageConfig, tempDir):
    debianDir = tempDir + "/" + packageConfig["debianDir"]
    os.makedirs(debianDir)

def processDebianPackage(packageConfig, options, tempDir):
    ret = True
    if options["outputDir"] != None:
        outputDir = options["outputDir"]
    else:
        outputDir = "."
    packageConfig = packageConfig.copy()
    packageConfig["preserveEnvironment"] = options["preserveEnvironment"]
    packageConfig["projectVersion"] = options["projectVersion"]
    packageConfig["buildImage"] = options["buildImage"]
    packageConfig["buildDir"] = options["buildImageMount"]
    packageConfig["outputDir"] = outputDir
    packageConfig["buildId"] = processDebianPackage.buildId
    packageConfig["packageSubdir"] = packageConfig["name"] + "-" + str(packageConfig["buildId"])
    packageConfig["maintainer"] = packageConfig["maintainer"] if "maintainer" in packageConfig else options["maintainer"]
    packageConfig["debianDir"] = packageConfig["packageSubdir"] + "/DEBIAN"

    if not "architecture" in packageConfig:
        packageConfig["architecture"] = "all"
        print("Warning: Missing architecture flag in configuration, supposing architecture \"all\".", file=sys.stderr)
    processDebianPackage.buildId += 1
    
    if options['list']:
        print(packageConfig["name"])
        return True
    
    print("Building package {} version {} for architecture {}".format(
        packageConfig["name"], packageConfig["projectVersion"], packageConfig["architecture"]
    ), file=sys.stderr)
    print("", file=sys.stderr)

    if options["dryRun"]:
        return True

    try:
        envVars = getEnvVars(packageConfig, False)
        invokePrepareCommand(packageConfig, False, envVars)
        createBasicPackageStruct(packageConfig, tempDir)
        createDebianControlFile(packageConfig, tempDir)
        installMaintainerScripts(packageConfig, tempDir)
        archive = createProjectArchive(tempDir, packageConfig)
        buildScript = createBuildScript(packageConfig, os.path.basename(archive), tempDir)
        
        debPackage = buildDebianPackage(packageConfig, buildScript, tempDir)

        if not os.path.isdir(packageConfig["outputDir"]):
            os.mkdir(packageConfig["outputDir"])
        shutil.copy(debPackage, packageConfig["outputDir"] + "/" + os.path.basename(debPackage))
    except Exception as e:
        print("Error: building debian package {} failed: {}".format(packageConfig["name"], e), file=sys.stderr)
        ret = False
    cleanupDebianBuild(packageConfig, tempDir, ret)
    return ret
processDebianPackage.buildId = 1

def mikdebOptionsChecker(options, config):
    #bypass options checking in case of just listing the images
    if options['list']:
        return True
    if not "projectVersion" in options or options["projectVersion"] == None:
        print("Error: missing project version")
        return False
    if not re.search(SEMVER_REGEXP, options["projectVersion"]):
        print("Error: Invalid project version: {}".format(options["projectVersion"]))
        return False
    if "output-dir" in config and config["output-dir"] != None and options["outputDir"] == None:
        options["outputDir"] = config["output-dir"]
    return True

APP_CONFIG = {
    "mikdim": {
        "processor": processImage,
        "configItemsKey": "images",
        "errorMessage": lambda name: "Warning: image {} not defined in the mikdim config file, ignoring".format(name),
        "integrationPlugins": ["version", "branch", "imagePrefix"],
        "optionsChecker": None,
        "defaultConfig": "mikdim.yaml"
    },
    "mikdeb": {
        "processor": processDebianPackage,
        "configItemsKey": "debian-packages",
        "errorMessage": lambda name: "Warning: debian package {} not defined in the mikdeb config file, ignoring".format(name),
        "integrationPlugins": ["version"],
        "optionsChecker": mikdebOptionsChecker,
        "defaultConfig": "mikdeb.yaml"
    }
}

def run(options):
    appConfig = APP_CONFIG[CMD]
    file = enterProject(options["project"], appConfig["defaultConfig"])
    if file == None:
        print("Error: config file not found", file=sys.stderr)
        return 1

    config = loadConfig(file)

    if config == None:
        print("Error: cannot load the config file", file=sys.stderr)
        return 3

    config = checkConfig(config)
    if config == None:
        print("Error: config file is invalid", file=sys.stderr)
        return 4

    processedObjects = {}

    runIntegrationPlugins(options, appConfig["integrationPlugins"])

    optionsChecker = appConfig["optionsChecker"]
    if optionsChecker != None and not optionsChecker(options, config):
        return 1
    
    ok = True

    # we want to list directly here, since we don't want to create the temporary directory
    # in case of just listing the images/debian packages
    if options['list']:
        for objectConfig in config[appConfig["configItemsKey"]]:
            if not appConfig["processor"](objectConfig, options, None):
                ok = False
        return 0 if ok else 5

    with tempfile.TemporaryDirectory() as tempDir:
        for objectConfig in config[appConfig["configItemsKey"]]:
            if options["wantedObjects"] != None:
                if not objectConfig["name"] in options["wantedObjects"]:
                    continue
                processedObjects[objectConfig["name"]] = True
            if not appConfig["processor"](objectConfig, options, tempDir):
                ok = False
        if options["wantedObjects"] != None:
            for wantedObject in options["wantedObjects"]:
                if not wantedObject in processedObjects:
                    print(appConfig["errorMessage"](wantedObject), file=sys.stderr)
    return 0 if ok else 5

options = parseOptions()

if options["help"]:
    printHelp()
    exit(1)

exit(run(options))
