#!/usr/bin/python3

import sys, getopt, os, subprocess, re, yaml, schema, tempfile, shutil, shlex
from pprint import pprint

commandName = os.path.basename(sys.argv[0])

if commandName == 'mikdeb':
    print("Warning: mikdeb is not yet fully implemented!", file=sys.stderr)
    CMD = 'mikdeb'
    DEFAULT_CONFIG = "mikdeb.yaml"
else:
    CMD = 'mikdim'
    DEFAULT_CONFIG = "mikdim.yaml"

SEMI_TAG = "semi-tmp"
DEV_TAG = "dev"
ALLOWED_BRANCHES = ["production", "staging", "master", "main"]
SEMVER_REGEXP = '^([0-9]+)\.([0-9]+)\.([0-9]+)(?:-([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?(?:\+[0-9A-Za-z-]+)?$'

DOCKERFILE_CONTENT = """# Dockerfile for building {finalImage} from {image} 
FROM {image}

COPY archive.tar.gz /tmp/archive.tar.gz
COPY postprocess.sh /tmp/postprocess.sh
RUN bash /tmp/postprocess.sh
"""

POSTPROCESS_CONTENT = """#!/bin/bash
set -e
final_dir={finalDir}
postprocess_script={postprocessScript}
mkdir -p "$final_dir"
cd "$final_dir"
tar xzf "/tmp/archive.tar.gz"
if [ -n "$postprocess_script" ]; then
    eval "$postprocess_script"
fi
rm -f "/tmp/archive.tar.gz"
rm -f "/tmp/postprocess.sh"
"""

SCHEMA = {
    "mikdim": {
        "images": [
            {
                "name": str,
                "build": str,
                schema.Optional("prepare-command"): schema.Or(str, [str]),
                schema.Optional("prepare-command-dev"): schema.Or(str, [str]),
                schema.Optional("project-dir"): str,
                schema.Optional("postprocess"): str,
                schema.Optional("environment"): {
                    schema.Optional(str): schema.Or(str, None)
                },
                schema.Optional("environment-dev"): {
                    schema.Optional(str): schema.Or(str, None)
                },
                schema.Optional("subdir"): str,
                schema.Optional("exclude"): [str],
                schema.Optional(str): object
            }
        ]
    },
    "mikdeb": {
        "debian-packages": [
            {
                "name": str,
                schema.Optional("prepare-command"): schema.Or(str, [str]),
                schema.Optional("project-dir"): str,
                schema.Optional("postprocess"): str,
                schema.Optional("environment"): {
                    schema.Optional(str): schema.Or(str, None)
                },
                schema.Optional("subdir"): str,
                schema.Optional("exclude"): [str],
                schema.Optional(str): object
            }
        ]
    }
}

def integrationPluginGit(options, detect):
    data = {}
    if detect["version"]:
        try:
            projectVersion = subprocess.check_output(["git", "describe"])
            projectVersion = projectVersion.decode("utf-8")
            projectVersion = projectVersion.strip()
        except:
            projectVersion = None
        if projectVersion != None:
            data["version"] = projectVersion

    if detect["branch"]:
        try:
            projectBranch = subprocess.check_output(["git", "rev-parse", "--abbrev-ref", "HEAD"])
            projectBranch = projectBranch.decode("utf-8")
            projectBranch = projectBranch.strip()
            if projectBranch == 'HEAD' or projectBranch == '':
                projectBranch = None
        except:
            projectBranch = None
        if projectBranch != None:
            data["branch"] = projectBranch
    return data

def getenv(key):
    return os.environ[key] if key in os.environ else None

def integrationPluginGitlab(options, detect):
    data = {}
    if detect["imagePrefix"]:
        imagePrefix = getenv("CI_REGISTRY_IMAGE")
        if imagePrefix != None and imagePrefix != '':
            data["imagePrefix"] = imagePrefix
    if detect["version"]:
        version = getenv("CI_COMMIT_TAG")
        if version != None and version != '':
            data["version"] = version
    if detect["branch"]:
        branch = getenv("CI_COMMIT_BRANCH")
        if branch != None and branch != '':
            data["branch"] = branch
    return data

INTEGRATION_PLUGINS = {
        "git": integrationPluginGit,
        "gitlab": integrationPluginGitlab
}

def optPush(command, args, params):
    if command == "create":
        return args["default"] if "default" in args else []
    elif command == "opt":
        return [":", "="]
    elif command == "val":
        unique = args["unique"] if "unique" in args else True
        if not unique or not params["val"] in params["oldVal"]:
            params["oldVal"].append(params["val"])
        return params["oldVal"]

def optPushNullable(command, args, params):
    if command == "create":
        return args["default"] if "default" in args else []
    elif command == "opt":
        return [":", "="]
    elif command == "val":
        opt = args["opt"].lstrip("-")
        if "nullableOpts" in args and opt in args["nullableOpts"]:
            return None
        if params["oldVal"] == None:
            return None
        return optPush(command, args, params)

def optPushOpt(command, args, params):
    if command == "create":
        return optPush(command, args, params)
    elif command == "opt":
        return ["", ""]
    elif command == "val":
        opt = params["opt"].lstrip("-")
        if "transform" in args and opt in args["transform"]:
            opt = args["transform"][opt]
        return optPush(command, args, {"val": opt, "opt": params["opt"], "oldVal": params["oldVal"]})

def optSetValue(command, args, params):
    if command == "create":
        return args["default"] if "default" in args else None
    elif command == "opt":
        return [":", "="]
    elif command == "val":
        return params["val"]

def optSet(command, args, params):
    default = True if (args["default"] if "default" in args else False) else False
    if command == "create":
        return default
    elif command == "opt":
        return ["", ""]
    elif command == "val":
        return not default

OPTIONS_ALL = {
    "integrationPlugins": {"fn": optPushOpt, "opts": ["G", "git", "L", "gitlab"], "transform": {"G": "git", "L": "gitlab"}},
    "project": {"fn": optSetValue, "opts": ["p", "project"]},
    "preserveEnvironment": {"fn": optSet, "opts": ["e", "preserve-environment"]},
    "dryRun": {"fn": optSet, "opts": ["D", "dry-run"]},
    "help": {"fn": optSet, "opts": ["h", "help"]}
}

OPTIONS_SPECIFIC = {
    "mikdim": {
        "devBuild": {"fn": optSet, "opts": ["d", "dev"], "setIfEmpty": ["prodBuild", True]},
        "prodBuild": {"fn": optSet, "opts": ["prod"]},
        "imagePrefix": {"fn": optSetValue, "opts": ["P", "prefix"]},
        "allowedBranches": {"fn": optPushNullable, "opts": ["a", "allow-branch", "A", "allow-all-branches"], "nullableOpts": ["A", "allow-all-branches"], "setIfEmpty": ["_self", ALLOWED_BRANCHES]},
        "tags": {"fn": optPush, "opts": ["t", "tag"]},
        "semiTag": {"fn": optSetValue, "opts": ["s", "semi-tag"], "default": SEMI_TAG},
        "projectVersioning": {"fn": optSet, "opts": ["n", "no-project-version"], "default": True},
        "projectBranchVersioning": {"fn": optSet, "opts": ["b", "no-project-branch"], "default": True},
        "wantedObjects": {"fn": optPush, "opts": ["i", "image"], "setIfEmpty": ["_self", None]},
        "push": {"fn": optSet, "opts": ["push"]},
        "pushOnly": {"fn": optSet, "opts": ["pushOnly"]},
        "untag": {"fn": optSet, "opts": ["u", "untag"]},
        "prune": {"fn": optSet, "opts": ["prune"]}
    },
    "mikdeb": {
        "wantedObjects": {"fn": optPush, "opts": ["P", "package"], "setIfEmpty": ["_self", None]},
    }
}

def helpPrint(options):
    finalOpts = []
    shortOptsLen = 0
    longOptsLen = 0
    for optionDef in options:
        [short, long, description, command, *x] = optionDef + [None]
        if command != None and CMD != command:
            continue
        shortOptsLen = max(shortOptsLen, len(short))
        longOptsLen = max(longOptsLen, len(long))
        finalOpts.append(optionDef)
    for optionDef in finalOpts:
        [short, long, description, *x] = optionDef
        shortLen = shortOptsLen - len(short)
        longLen = longOptsLen - len(long)
        print("  {}{} {}{}  - {}".format(short, " " * shortLen, long, " " * longLen, description), file=sys.stderr)

def printHelp():
    print("usage: {} [options]".format(sys.argv[0]), file=sys.stderr)
    print("options:", file=sys.stderr)
    helpPrint([
        ["-d", "--dev",                    "invoke dev build of the images", "mikdim"],
        ["",   "--prod",                   "invoke prod build of the images", "mikdim"],
        ["-t", "--tag <tag>",              "specify some another special tag", "mikdim"],
        ["-p", "--project <project>",      "specify directory or config file of the project where images should be built"],
        ["-P", "--prefix <image-prefix>",  "specify image prefix", "mikdim"],
        ["-G", "--git",                    "Use branch/version from git", "mikdim"],
        ["-G", "--git",                    "Use version from git", "mikdeb"],
        ["-L", "--gitlab",                 "Use branch/version from gitlab CI variables", "mikdim"],
        ["-L", "--gitlab",                 "Use version from gitlab CI variables", "mikdeb"],
        ["-n", "--no-project-version",     "disable project version tagging (use with --git or --gitlab)", "mikdim"],
        ["-b", "--no-project-branch",      "disable project branch tagging (use with --git or --gitlab)", "mikdim"],
        ["-e", "--preserve-environment",   "preserve environment variables"],
        ["-a", "--allow-branch <branch>",  "allow branch name (default branch names if none given are {})".format(", ".join(ALLOWED_BRANCHES)), "mikdim"],
        ["-A", "--allow-all-branches",     "allow all branch names", "mikdim"],
        ["-i", "--image <image-name>",     "build only this image (multiple images may be specified)", "mikdim"],
        ["-P", "--package <package-name>", "build only this package (multiple packages may be specified)", "mikdeb"],
        ["-s", "--semi-tag <tag>",         "specify the tag of the semiproduct (default '{}')".format(SEMI_TAG), "mikdim"],
        ["-D", "--dry-run",                "just print building info and exit"],
        ["",   "--push",                   "push the images to the registry (registry login is not part of this command)", "mikdim"],
        ["",   "--push-only",              "only push the images, don't build", "mikdim"],
        ["-u", "--untag",                  "untag images after build (and push) is finished", "mikdim"],
        ["",   "--prune",                  "prune the image and builder cache", "mikdim"],
        ["-h", "--help",                   "show this help"]
    ])

def parseOptions():
    optionsDef = {}
    optionsDef.update(OPTIONS_ALL)
    optionsDef.update(OPTIONS_SPECIFIC[CMD])

    options = {}
    shortOpts = ""
    longOpts = []
    optMap = {}

    for (key, optDef) in optionsDef.items():
        fn = optDef["fn"]
        options[key] = fn("create", optDef, {})
        (shortSuffix, longSuffix) = fn("opt", optDef, {})
        for opt in optDef["opts"]:
            if len(opt) > 0:
                if len(opt) == 1:
                    optMap["-" + opt] = key
                    shortOpts += opt + shortSuffix
                else:
                    optMap["--" + opt] = key
                    longOpts += [opt + longSuffix]


    (opts, args) = getopt.getopt(sys.argv[1:], shortOpts, longOpts)
    for (opt, value) in opts:
        key = optMap[opt]
        optDef = optionsDef[key]
        fn = optDef["fn"]
        options[key] = fn("val", optDef, {"opt": opt, "val": value, "oldVal": options[key]})

    for (key, optDef) in optionsDef.items():
        if "setIfEmpty" in optDef and not options[key]:
            (myKey, myValue) = optDef["setIfEmpty"]
            if myKey == "_self" or myKey == None:
                myKey = key
            options[myKey] = myValue

    return options 

def enterProject(project):
    if project == None:
        project = "."
    if os.path.isdir(project):
        os.chdir(project)
        file = DEFAULT_CONFIG
    elif os.path.isfile(project):
        os.chdir(os.path.dirname(project))
        file = os.path.basename(project)
    if os.path.isfile(file):
        return file
    return None

def loadConfig(file):
    with open(file, "r") as stream:
        try:
            config = yaml.safe_load(stream)
        except:
            return None
    return config

def checkConfig(config):
    configSchema = schema.Schema(SCHEMA[CMD])
    try:
        return configSchema.validate(config)
    except:
        return None

def putFile(directory, file, template, *args, **kwargs):
    file = "{}/{}".format(directory, file)
    if args or kwargs:
        content = template.format(*args, **kwargs)
    else:
        content = template
    with open(file, 'w') as f:
        f.write(content)


def createProjectArchive(tempDir, subdir, excludeDirs):
    archive = "{}/archive-{}.tar.gz".format(os.path.realpath(tempDir), createProjectArchive.archiveNumber)
    createProjectArchive.archiveNumber += 1
    excludeArgs = []
    if not os.path.isdir(subdir):
        raise Exception("Image sbdir is not a directory")
    for excludeDir in excludeDirs:
        excludeArgs.append("--exclude")
        excludeArgs.append(re.sub(r'^/*', './', excludeDir))
    cwd = os.getcwd()
    os.chdir(subdir)
    if subprocess.run(["tar", "-czf", archive, "--exclude", "./.git"] + excludeArgs + ["."]).returncode != 0:
        raise Exception("Cannot create archive")
    os.chdir(cwd)
    return archive

createProjectArchive.archiveNumber = 1

def getEnvVars(imageConfig, devBuild):
    envKey = 'environment-dev' if devBuild else 'environment'
    env = None
    if not imageConfig['preserveEnvironment']:
        env = {}
    if not (envKey in imageConfig):
        return env
    if env == None:
        env = dict(os.environ)
    for var, val in imageConfig[envKey].items():
        if val != None:
            env[var] = val
        elif var in env:
            del env[var]
    return env

def buildSemiProduct(imageConfig, tempDir, envVars):
    if not os.path.isdir(imageConfig['build']):
        raise Exception("Build directory of image '{}' is not a directory".format(imageConfig['finalImage']))
    if not os.path.isfile("{}/Dockerfile".format(imageConfig['build'])):
        raise Exception("Build directory does not contain Dockerfile")
    imageArgs = []
    for img in imageConfig["semiImages"]:
        imageArgs.append("-t");
        imageArgs.append(img)
    if subprocess.run(["docker", "build", "--pull"] + imageArgs + [imageConfig['build']], env=envVars).returncode != 0:
        raise Exception("Cannot build semiproduct image")

def buildFinalProduct(imageConfig, tempDir, projectArchive):
    dockerDir = "{}/docker-{}".format(tempDir, imageConfig['name'])
    os.mkdir(dockerDir)
    finalDir = imageConfig["project-dir"] if "project-dir" in imageConfig else "/workspace"
    postprocessScript = imageConfig["postprocess"] if "postprocess" in imageConfig else ""
    putFile(dockerDir, "Dockerfile", DOCKERFILE_CONTENT, image=imageConfig["semiImages"][0], finalImage=imageConfig["finalImage"])
    putFile(dockerDir, "postprocess.sh", POSTPROCESS_CONTENT, finalDir=shlex.quote(finalDir), postprocessScript=shlex.quote(postprocessScript))
    shutil.copy(projectArchive, "{}/archive.tar.gz".format(dockerDir))
    imageArgs = []
    for img in imageConfig["finalImages"]:
        imageArgs.append("-t");
        imageArgs.append(img)
    if imageArgs:
        if subprocess.run(["docker", "build"] + imageArgs + [dockerDir]).returncode != 0:
            raise Exception("Cannot build final production image")
    else:
        raise Exception("No final tag specified")
    shutil.rmtree(dockerDir)

def pushTags(imageConfig):
    failed = False
    for image in imageConfig["finalImages"]:
        if subprocess.run(["docker", "push", "--", image]).returncode != 0:
            failed = True
    if failed:
        raise Exception("Cannot push tags")

def cleanupBuild(imageConfig, tempDir):
    for tag in imageConfig["cleanupImages"]:
        subprocess.run(["docker", "image", "rm", "-f", "--", tag])
    if imageConfig["prune"]:
        subprocess.run(["docker", "image", "prune", "-f"])
        subprocess.run(["docker", "builder", "prune", "-f"])

def createFinalImageName(name, options):
    imagePrefix = options["imagePrefix"]

    if imagePrefix == '':
        imagePrefix = None

    if imagePrefix == None:
        return name

    if name == 'main':
        return options["imagePrefix"]

    return options["imagePrefix"] + "/" + name

def unique(array):
    finalArray = []
    for item in array:
        if not item in finalArray:
            finalArray.append(item)
    return finalArray

def tagToImage(tag, image):
    return "{}:{}".format(image, tag)

def tagsToImages(tags, image):
    images = []
    for tag in unique(tags):
        images.append(tagToImage(tag, image))
    return images


def getIntegrationPlugin(name):
    if name in INTEGRATION_PLUGINS:
        return INTEGRATION_PLUGINS[name]
    return None

def detectVersion(projectVersion):
    projectVersion = projectVersion.strip()
    reMatch = re.search('^v?(.*)$', projectVersion)
    if reMatch:
        projectVersion = reMatch[1]

    if not re.search(SEMVER_REGEXP, projectVersion):
        return None
    return projectVersion

def runIntegrationPlugins(options):
    data = {}
    detectAll = ["version", "branch", "imagePrefix"]
    detect = dict.fromkeys(detectAll, True)
    for plugin in options["integrationPlugins"]:
        plugin = getIntegrationPlugin(plugin)
        if plugin != None:
            pluginData = {}
            pluginData.update(plugin(options, detect))
            for key in pluginData.keys():
                if pluginData[key] == None:
                    del pluginData[key]
            pluginData.update(data)
            data = pluginData
            
            detectAllNew = []
            for d in detectAll:
                if d in data and data[d] != None:
                    detect[d] = False
                else:
                    detectAllNew.append(d)
            detectAll = detectAllNew
        else:
            data = {}

    tags = []
    if "version" in data and data["version"] != None and options["projectVersioning"]:
        version = detectVersion(data["version"])
        if version != None:
            tags.append(version)
    if "branch" in data and data["branch"] != None and options["projectBranchVersioning"]:
        branch = data["branch"]
        if options['allowedBranches'] == None or branch in options['allowedBranches']:
            tags.append(branch)

    options["integrationTags"] = tags
    if (not "imagePrefix" in options or options["imagePrefix"] == None) and "imagePrefix" in data:
        options["imagePrefix"] = data["imagePrefix"]

def invokePrepareCommand(objectConfig, devBuild, envVars):
    if devBuild:
        prepareCommandKey = 'prepare-command-dev'
    else:
        prepareCommandKey = 'prepare-command'

    prepareCommand = objectConfig[prepareCommandKey] if 'prepare-command' in objectConfig else None

    if isinstance(prepareCommand, str):
        prepareCommand = ["bash", "-c", prepareCommand]

    if prepareCommand == None:
        return
    if not prepareCommand:
        raise Exception("Cannot invoke empty prepare command")
    if subprocess.run(prepareCommand, env=envVars).returncode != 0:
        raise Exception("Prepare command failed")



def processSingleImage(imageConfig, options, tempDir, devBuild, tags):
    imageConfig = imageConfig.copy()
    imageConfig["preserveEnvironment"] = options["preserveEnvironment"]
    imageConfig["finalImage"] = createFinalImageName(imageConfig["name"], options)
    imageConfig["semiImages"] = []
    imageConfig["cleanupImages"] = []
    imageConfig["prune"] = options["prune"]

    imageConfig["finalTags"] = tags
    
    if devBuild:
        if not imageConfig["finalTags"]:
            imageConfig["finalTags"].append(DEV_TAG)
    else:
        semiImage = tagToImage(options["semiTag"], imageConfig["finalImage"])
        imageConfig["semiImages"].append(semiImage)
        imageConfig["cleanupImages"].append(semiImage)

    imageConfig["finalImages"] = tagsToImages(imageConfig["finalTags"], imageConfig["finalImage"])

    if options["untag"]:
        imageConfig["cleanupImages"] = imageConfig["cleanupImages"] + imageConfig["finalImages"]

    if devBuild:
        imageConfig['semiImages'] = imageConfig["finalImages"]
    
    subdir = imageConfig['subdir'] if 'subdir' in imageConfig else '.'
    exclude = imageConfig['exclude'] if 'exclude' in imageConfig else []
    
    print("Building image {} as {}".format(imageConfig["finalImage"], "dev" if devBuild else "prod"), file=sys.stderr)
    if not devBuild:
        print("Semiproduct image: {}".format(imageConfig["semiImages"][0]), file=sys.stderr)
    print("Tags: {}".format(", ".join(imageConfig["finalTags"])), file=sys.stderr)
    if options["push"]:
        print("Images will be pushed to the repository", file=sys.stderr)
    print("", file=sys.stderr)

    if options["dryRun"]:
        return True

    if not imageConfig["finalTags"]:
        print("Warning: no tags given for building this image, skipping", file=sys.stderr)
        return True

    ret = True
    try:
        envVars = getEnvVars(imageConfig, devBuild)
        if not options["pushOnly"]:
            invokePrepareCommand(imageConfig, devBuild, envVars)
            if not devBuild:
                archive = createProjectArchive(tempDir, subdir, exclude)
            buildSemiProduct(imageConfig, tempDir, envVars)
            if not devBuild:
                buildFinalProduct(imageConfig, tempDir, archive)
        if options["push"] or options["pushOnly"]:
            pushTags(imageConfig)
    except Exception as e:
        print("Error: building image {} failed: {}".format(imageConfig["finalImage"], e), file=sys.stderr)
        ret = False
    cleanupBuild(imageConfig, tempDir)
    return ret

def processImage(imageConfig, options, tempDir):
    ok = True
    tags = options["integrationTags"] + options["tags"]
    if options["prodBuild"]:
        if not processSingleImage(imageConfig, options, tempDir, False, tags):
            ok = False
    if options["devBuild"]:
        if options["prodBuild"]:
            tags = [DEV_TAG]
        if not processSingleImage(imageConfig, options, tempDir, True, tags):
            ok = False
    return ok

def processDebianPackage(packageConfig, options, tempDir):
    ret = True
    try:
        pass
        raise Exception("processing debian package not implemented")
    except Exception as e:
        print("Error: building debian package {} failed: {}".format(packageConfig["name"], e), file=sys.stderr)
        ret = False
    return ret

APP_CONFIG = {
    "mikdim": {
        "processor": processImage,
        "configItemsKey": "images",
        "errorMessage": lambda name: "Warning: image {} not defined in the mikdim config file, ignoring".format(name)
    },
    "mikdeb": {
        "processor": processDebianPackage,
        "configItemsKey": "debian-packages",
        "errorMessage": lambda name: "Warning: debian package {} not defined in the mikdeb config file, ignoring".format(name)
    }
}

def run(options):
    appConfig = APP_CONFIG[CMD]
    file = enterProject(options["project"])
    if file == None:
        print("Error: config file not found", file=sys.stderr)
        return 1

    config = loadConfig(file)

    if config == None:
        print("Error: cannot load the config file", file=sys.stderr)
        return 3

    config = checkConfig(config)
    if config == None:
        print("Error: config file is invalid", file=sys.stderr)
        return 4
    
    processedObjects = {}

    runIntegrationPlugins(options)

    ok = True

    with tempfile.TemporaryDirectory() as tempDir:
        for objectConfig in config[appConfig["configItemsKey"]]:
            if options["wantedObjects"] != None:
                if not objectConfig["name"] in options["wantedObjects"]:
                    continue
                processedObjects[objectConfig["name"]] = True
            if not appConfig["processor"](objectConfig, options, tempDir):
                ok = False
        if options["wantedObjects"] != None:
            for wantedObject in options["wantedObjects"]:
                if not wantedObject in processedObjects:
                    print(appConfig["errorMessage"](wantedObject), file=sys.stderr)
    return 0 if ok else 5

options = parseOptions()

if options["help"]:
    printHelp()
    exit(1)

exit(run(options))

