#!/usr/bin/python3

import sys, getopt, os, subprocess, re, yaml, schema, tempfile, shutil, shlex
from pprint import pprint

DEFAULT_CONFIG = "mikdim.yaml"
SEMI_TAG = "semi-tmp"
DEV_TAG = "dev"
ALLOWED_BRANCHES = ["production", "staging", "master", "main"]
SEMVER_REGEXP = '^([0-9]+)\.([0-9]+)\.([0-9]+)(?:-([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?(?:\+[0-9A-Za-z-]+)?$'

DOCKERFILE_CONTENT = """# Dockerfile for building {finalImage} from {image} 
FROM {image}

COPY archive.tar.gz /tmp/archive.tar.gz
COPY postprocess.sh /tmp/postprocess.sh
RUN bash /tmp/postprocess.sh
"""

POSTPROCESS_CONTENT = """#!/bin/bash
set -e
final_dir={finalDir}
postprocess_script={postprocessScript}
mkdir -p "$final_dir"
cd "$final_dir"
tar xzf "/tmp/archive.tar.gz"
if [ -n "$postprocess_script" ]; then
    eval "$postprocess_script"
fi
rm -f "/tmp/archive.tar.gz"
rm -f "/tmp/postprocess.sh"
"""

def integrationPluginGit(options, detect):
    data = {}
    if detect["version"]:
        try:
            projectVersion = subprocess.check_output(["git", "describe"])
            projectVersion = projectVersion.decode("utf-8")
            projectVersion = projectVersion.strip()
        except:
            projectVersion = None
        if projectVersion != None:
            data["version"] = projectVersion

    if detect["branch"]:
        try:
            projectBranch = subprocess.check_output(["git", "rev-parse", "--abbrev-ref", "HEAD"])
            projectBranch = projectBranch.decode("utf-8")
            projectBranch = projectBranch.strip()
            if projectBranch == 'HEAD' or projectBranch == '':
                projectBranch = None
        except:
            projectBranch = None
        if projectBranch != None:
            data["branch"] = projectBranch
    return data

def getenv(key):
    return os.environ[key] if key in os.environ else None

def integrationPluginGitlab(options, detect):
    data = {}
    if detect["imagePrefix"]:
        imagePrefix = getenv("CI_REGISTRY_IMAGE")
        if imagePrefix != None and imagePrefix != '':
            data["imagePrefix"] = imagePrefix
    if detect["version"]:
        version = getenv("CI_COMMIT_TAG")
        if version != None and version != '':
            data["version"] = version
    if detect["branch"]:
        branch = getenv("CI_COMMIT_BRANCH")
        if branch != None and branch != '':
            data["branch"] = branch
    return data

INTEGRATION_PLUGINS = {
        "git": integrationPluginGit,
        "gitlab": integrationPluginGitlab
}

def printHelp():
    print("usage: {} [options]".format(sys.argv[0]), file=sys.stderr)
    print("options:", file=sys.stderr)
    print("  -d --dev                       - invoke dev build of the images")
    print("     --prod                      - invoke prod build of the images")
    print("  -t --tag <tag>                 - specify some another special tag", file=sys.stderr)
    print("  -p --project <project>         - specify directory or config file of the project where images should be built", file=sys.stderr)
    print("  -P --prefix <image-prefix>     - specify image prefix", file=sys.stderr)
    print("  -G --git                       - Use branch/version from git", file=sys.stderr)
    print("  -L --gitlab                    - Use branch/version from gitlab CI variables", file=sys.stderr)
    print("  -n --no-project-version        - disable project version tagging (use with --git or --gitlab)", file=sys.stderr)
    print("  -b --no-project-branch         - disable project branch tagging (use with --git or --gitlab)", file=sys.stderr)
    print("  -e --preserve-environment      - preserve environment variables", file=sys.stderr)
    print("  -a --allow-branch <branch>     - allow branch name (default branch names if none given are {})".format(", ".join(ALLOWED_BRANCHES)), file=sys.stderr)
    print("  -A --allow-all-branches        - allow all branch names", file=sys.stderr)
    print("  -i --image <image-name>        - build only this image (multiple images may be specified)", file=sys.stderr)
    print("  -s --semi-tag <tag>            - specify the tag of the semiproduct (default '{}')".format(SEMI_TAG), file=sys.stderr)
    print("  -D --dry-run                   - just print building info and exit", file=sys.stderr)
    print("     --push                      - push the images to the registry (registry login is not part of this command)", file=sys.stderr)
    print("     --push-only                 - only push the images, don't build", file=sys.stderr)
    print("  -u --untag                     - untag images after build (and push) is finished", file=sys.stderr)
    print("     --prune                     - prune the image and builder cache", file=sys.stderr)
    print("  -h --help                      - show this help", file=sys.stderr)

def parseOptions():
    options = {
        "integrationPlugins": [],
        "devBuild": False,
        "prodBuild": False,
        "imagePrefix": None,
        "allowedBranches": [],
        "tags": [],
        "project": None,
        "projectVersioning": True,
        "projectBranchVersioning": True,
        "preserveEnvironment": False,
        "semiTag": SEMI_TAG,
        "help": False,
        "dryRun": False,
        "push": False,
        "pushOnly": False,
        "untag": False,
        "prune": False,
        "wantedImages": []
    }
    (opts, args) = getopt.getopt(
        sys.argv[1:],
        "dt:p:P:s:a:i:AhnbeGLDu",
        [
            "project=", "prefix=", "semi-tag=", "tag=", "allow-branch=", "image=", "allow-all-branches=",
            "dev", "no-project-version", "no-project-branch", "help", "preserve-environment",
            "git", "gitlab", "dry-run", "prod", "push", "push-only", "untag", "prune"
        ]
    )
    for (opt, value) in opts:
        if (opt == '-d' or opt == '--dev'):
            options["devBuild"] = True
        elif (opt == '--prod'):
            options['prodBuild'] = True
        elif (opt == '-t' or opt == '--tag'):
            options["tags"].append(value)
        elif (opt == '-p' or opt == '--project'):
            options["project"] = value
        elif (opt == '-P' or opt == '--prefix'):
            options["imagePrefix"] = value
        elif (opt == '-s' or opt == '--semi-tag'):
            options['semiTag'] = value
        elif (opt == '-h' or opt == '--help'):
        	options['help']= True
        elif (opt == '-n' or opt == '--no-project-version'):
        	options['projectVersioning']= False
        elif (opt == '-b' or opt == '--no-project-branch'):
        	options['projectBranchVersioning']= False
        elif (opt == '-e' or opt == '--preserve-environment'):
        	options['preserveEnvironment']= True
        elif (opt == '-a' or opt == '--allow-branch'):
            if options['allowedBranches'] != None:
                options['allowedBranches'].append(value)
        elif (opt == '-A' or opt == '--allow-all-branches'):
            options['allowedBranches'] = None
        elif (opt == '-i' or opt == '--image'):
        	options['wantedImages'].append(value)
        elif (opt == '-G' or opt == '--git'):
            if not "git" in options["integrationPlugins"]:
                options['integrationPlugins'].append("git")
        elif (opt == '-L' or opt == '--gitlab'):
            if not "gitlab" in options["integrationPlugins"]:
                options['integrationPlugins'].append("gitlab")
        elif (opt == '-D' or opt == '--dry-run'):
            options['dryRun'] = True
        elif (opt == '--push'):
            options['push'] = True
        elif (opt == '--push-only'):
            options['pushOnly'] = True
        elif (opt == '-u' or opt == '--untag'):
            options['untag'] = True
        elif (opt == '--prune'):
            options['prune'] = True

    if not options['wantedImages']:
        options['wantedImages'] = None

    if not options["devBuild"]:
        options["prodBuild"] = True

    if not options["allowedBranches"]:
        options["allowedBranches"] += ALLOWED_BRANCHES

    return options 

def enterProject(project):
    if project == None:
        project = "."
    if os.path.isdir(project):
        os.chdir(project)
        file = DEFAULT_CONFIG
    elif os.path.isfile(project):
        os.chdir(os.path.dirname(project))
        file = os.path.basename(project)
    if os.path.isfile(file):
        return file
    return None

def loadConfig(file):
    with open(file, "r") as stream:
        try:
            config = yaml.safe_load(stream)
        except:
            return None
    return config

def checkConfig(config):
    configSchema = schema.Schema({
        "images": [
            {
                "name": str,
                "build": str,
                schema.Optional("prepare-command"): schema.Or(str, [str]),
                schema.Optional("prepare-command-dev"): schema.Or(str, [str]),
                schema.Optional("project-dir"): str,
                schema.Optional("postprocess"): str,
                schema.Optional("environment"): {
                    schema.Optional(str): schema.Or(str, None)
                },
                schema.Optional("environment-dev"): {
                    schema.Optional(str): schema.Or(str, None)
                },
                schema.Optional("subdir"): str,
                schema.Optional("exclude"): [str],
                schema.Optional(str): object
            }
        ]
    })
    try:
        return configSchema.validate(config)
    except:
        return None

def putFile(directory, file, template, *args, **kwargs):
    file = "{}/{}".format(directory, file)
    if args or kwargs:
        content = template.format(*args, **kwargs)
    else:
        content = template
    with open(file, 'w') as f:
        f.write(content)


def createProjectArchive(tempDir, subdir, excludeDirs):
    archive = "{}/archive-{}.tar.gz".format(os.path.realpath(tempDir), createProjectArchive.archiveNumber)
    createProjectArchive.archiveNumber += 1
    excludeArgs = []
    if not os.path.isdir(subdir):
        raise Exception("Image sbdir is not a directory")
    for excludeDir in excludeDirs:
        excludeArgs.append("--exclude")
        excludeArgs.append(re.sub(r'^/*', './', excludeDir))
    cwd = os.getcwd()
    os.chdir(subdir)
    if subprocess.run(["tar", "-czf", archive, "--exclude", "./.git"] + excludeArgs + ["."]).returncode != 0:
        raise Exception("Cannot create archive")
    os.chdir(cwd)
    return archive

createProjectArchive.archiveNumber = 1

def getEnvVars(imageConfig, production):
    envKey = 'environment' if production else 'environment-dev'
    env = None
    if not imageConfig['preserveEnvironment']:
        env = {}
    if not (envKey in imageConfig):
        return env
    if env == None:
        env = dict(os.environ)
    for var, val in imageConfig[envKey].items():
        if val != None:
            env[var] = val
        elif var in env:
            del env[var]
    return env

def buildSemiProduct(imageConfig, tempDir):
    if not os.path.isdir(imageConfig['build']):
        raise Exception("Build directory of image '{}' is not a directory".format(imageConfig['finalImage']))
    if not os.path.isfile("{}/Dockerfile".format(imageConfig['build'])):
        raise Exception("Build directory does not contain Dockerfile")
    imageArgs = []
    for img in imageConfig["semiImages"]:
        imageArgs.append("-t");
        imageArgs.append(img)
    if subprocess.run(["docker", "build", "--pull"] + imageArgs + [imageConfig['build']], env=getEnvVars(imageConfig, True)).returncode != 0:
        raise Exception("Cannot build semiproduct image")

def buildFinalProduct(imageConfig, tempDir, projectArchive):
    dockerDir = "{}/docker-{}".format(tempDir, imageConfig['name'])
    os.mkdir(dockerDir)
    finalDir = imageConfig["project-dir"] if "project-dir" in imageConfig else "/workspace"
    postprocessScript = imageConfig["postprocess"] if "postprocess" in imageConfig else ""
    putFile(dockerDir, "Dockerfile", DOCKERFILE_CONTENT, image=imageConfig["semiImages"][0], finalImage=imageConfig["finalImage"])
    putFile(dockerDir, "postprocess.sh", POSTPROCESS_CONTENT, finalDir=shlex.quote(finalDir), postprocessScript=shlex.quote(postprocessScript))
    shutil.copy(projectArchive, "{}/archive.tar.gz".format(dockerDir))
    imageArgs = []
    for img in imageConfig["finalImages"]:
        imageArgs.append("-t");
        imageArgs.append(img)
    if imageArgs:
        if subprocess.run(["docker", "build"] + imageArgs + [dockerDir]).returncode != 0:
            raise Exception("Cannot build final production image")
    else:
        raise Exception("No final tag specified")
    shutil.rmtree(dockerDir)

def pushTags(imageConfig):
    failed = False
    for image in imageConfig["finalImages"]:
        if subprocess.run(["docker", "push", "--", image]).returncode != 0:
            failed = True
    if failed:
        raise Exception("Cannot push tags")

def cleanupBuild(imageConfig, tempDir):
    for tag in imageConfig["cleanupImages"]:
        subprocess.run(["docker", "image", "rm", "-f", "--", tag])
    if imageConfig["prune"]:
        subprocess.run(["docker", "image", "prune", "-f"])
        subprocess.run(["docker", "builder", "prune", "-f"])

def createFinalImageName(name, options):
    imagePrefix = options["imagePrefix"]

    if imagePrefix == '':
        imagePrefix = None

    if imagePrefix == None:
        return name

    if name == 'main':
        return options["imagePrefix"]

    return options["imagePrefix"] + "/" + name

def unique(array):
    finalArray = []
    for item in array:
        if not item in finalArray:
            finalArray.append(item)
    return finalArray

def tagToImage(tag, image):
    return "{}:{}".format(image, tag)

def tagsToImages(tags, image):
    images = []
    for tag in unique(tags):
        images.append(tagToImage(tag, image))
    return images


def getIntegrationPlugin(name):
    if name in INTEGRATION_PLUGINS:
        return INTEGRATION_PLUGINS[name]
    return None

def detectVersion(projectVersion):
    projectVersion = projectVersion.strip()
    reMatch = re.search('^v?(.*)$', projectVersion)
    if reMatch:
        projectVersion = reMatch[1]

    if not re.search(SEMVER_REGEXP, projectVersion):
        return None
    return projectVersion

def runIntegrationPlugins(options):
    data = {}
    detectAll = ["version", "branch", "imagePrefix"]
    detect = dict.fromkeys(detectAll, True)
    for plugin in options["integrationPlugins"]:
        plugin = getIntegrationPlugin(plugin)
        if plugin != None:
            pluginData = {}
            pluginData.update(plugin(options, detect))
            for key in pluginData.keys():
                if pluginData[key] == None:
                    del pluginData[key]
            pluginData.update(data)
            data = pluginData
            
            detectAllNew = []
            for d in detectAll:
                if d in data and data[d] != None:
                    detect[d] = False
                else:
                    detectAllNew.append(d)
            detectAll = detectAllNew
        else:
            data = {}

    tags = []
    if "version" in data and data["version"] != None and options["projectVersioning"]:
        version = detectVersion(data["version"])
        if version != None:
            tags.append(version)
    if "branch" in data and data["branch"] != None and options["projectBranchVersioning"]:
        branch = data["branch"]
        if options['allowedBranches'] == None or branch in options['allowedBranches']:
            tags.append(branch)

    options["integrationTags"] = tags
    if options["imagePrefix"] == None and "imagePrefix" in data:
        options["imagePrefix"] = data["imagePrefix"]

def invokePrepareCommand(imageConfig, options, devBuild):
    if devBuild:
        prepareCommandKey = 'prepare-command-dev'
    else:
        prepareCommandKey = 'prepare-command'

    prepareCommand = imageConfig[prepareCommandKey] if 'prepare-command' in imageConfig else None

    if isinstance(prepareCommand, str):
        prepareCommand = ["bash", "-c", prepareCommand]

    if prepareCommand == None:
        return
    if not prepareCommand:
        raise Exception("Cannot invoke empty prepare command")
    if subprocess.run(prepareCommand).returncode != 0:
        raise Exception("Prepare command failed")



def processSingleImage(imageConfig, options, tempDir, devBuild, tags):
    imageConfig = imageConfig.copy()
    imageConfig["preserveEnvironment"] = options["preserveEnvironment"]
    imageConfig["finalImage"] = createFinalImageName(imageConfig["name"], options)
    imageConfig["semiImages"] = []
    imageConfig["cleanupImages"] = []
    imageConfig["prune"] = options["prune"]

    imageConfig["finalTags"] = tags
    
    if devBuild:
        if not imageConfig["finalTags"]:
            imageConfig["finalTags"].append(DEV_TAG)
    else:
        semiImage = tagToImage(options["semiTag"], imageConfig["finalImage"])
        imageConfig["semiImages"].append(semiImage)
        imageConfig["cleanupImages"].append(semiImage)

    imageConfig["finalImages"] = tagsToImages(imageConfig["finalTags"], imageConfig["finalImage"])

    if options["untag"]:
        imageConfig["cleanupImages"] = imageConfig["cleanupImages"] + imageConfig["finalImages"]

    if devBuild:
        imageConfig['semiImages'] = imageConfig["finalImages"]
    
    subdir = imageConfig['subdir'] if 'subdir' in imageConfig else '.'
    exclude = imageConfig['exclude'] if 'exclude' in imageConfig else []
    
    print("Building image {} as {}".format(imageConfig["finalImage"], "dev" if devBuild else "prod"), file=sys.stderr)
    if not devBuild:
        print("Semiproduct image: {}".format(imageConfig["semiImages"][0]), file=sys.stderr)
    print("Tags: {}".format(", ".join(imageConfig["finalTags"])), file=sys.stderr)
    if options["push"]:
        print("Images will be pushed to the repository", file=sys.stderr)
    print("", file=sys.stderr)

    if options["dryRun"]:
        return True

    if not imageConfig["finalTags"]:
        print("Warning: no tags given for building this image, skipping", file=sys.stderr)
        return True

    ret = True
    try:
        if not options["pushOnly"]:
            invokePrepareCommand(imageConfig, options, devBuild)
            if not devBuild:
                archive = createProjectArchive(tempDir, subdir, exclude)
            buildSemiProduct(imageConfig, tempDir)
            if not devBuild:
                buildFinalProduct(imageConfig, tempDir, archive)
        if options["push"] or options["pushOnly"]:
            pushTags(imageConfig)
    except Exception as e:
        print("Error: building image {} failed: {}".format(imageConfig["finalImage"], e), file=sys.stderr)
        ret = False
    cleanupBuild(imageConfig, tempDir)
    return ret

def run(options):
    file = enterProject(options["project"])
    if file == None:
        print("Error: config file not found", file=sys.stderr)
        return 1

    config = loadConfig(file)

    if config == None:
        print("Error: cannot load the config file", file=sys.stderr)
        return 3

    config = checkConfig(config)
    if config == None:
        print("Error: config file is invalid", file=sys.stderr)
        return 4
    
    processedImages = {}

    runIntegrationPlugins(options)

    ok = True

    with tempfile.TemporaryDirectory() as tempDir:
        for imageConfig in config["images"]:
            if options["wantedImages"] != None:
                if not imageConfig["name"] in options["wantedImages"]:
                    continue
                processedImages[imageConfig["name"]] = True
            tags = options["integrationTags"] + options["tags"]
            if options["prodBuild"]:
                if not processSingleImage(imageConfig, options, tempDir, False, tags):
                    ok = False
            if options["devBuild"]:
                if options["prodBuild"]:
                    tags = [DEV_TAG]
                if not processSingleImage(imageConfig, options, tempDir, True, tags):
                    ok = False
        if options["wantedImages"] != None:
            for wantedImage in options["wantedImages"]:
                if not wantedImage in processedImages:
                    print("Warning: image {} not defined in the mikdim config file, ignoring".format(wantedImage), file=sys.stderr)
    return 0 if ok else 5

options = parseOptions()

if options["help"]:
    printHelp()
    exit(1)

exit(run(options))

